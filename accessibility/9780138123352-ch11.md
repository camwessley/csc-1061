# Chapter 11 Inheritance and Polymorphism

## Learning Objectives

  1. 11.1 To define a subclass from a superclass through inheritance §(§11.2).

  2. 11.2 To invoke the superclass’s constructors and methods using the `super` keyword §(§11.3).

  3. 11.3 To override instance methods in the subclass §(§11.4).

  4. 11.4 To distinguish differences between overriding and overloading §(§11.5).

  5. 11.5 To explore the `toString()` method in the `Object` class §(§11.6).

  6. 11.6 To discover polymorphism and dynamic binding §§(§§11.7 and 11.8).

  7. 11.7 To describe casting and explain why explicit downcasting is necessary §(§11.9).

  8. 11.8 To explore the `equals` method in the `Object` class §(§11.10).

  9. 11.9 To store, retrieve, and manipulate objects in an `ArrayList` §(§11.11).

  10. 11.10 To construct an array list from an array, to sort and shuffle a list, and to obtain max and min element from a list §(§11.12).

  11. 11.11 To implement a `Stack` class using `ArrayList` §(§11.13).

  12. 11.12 To enable data and methods in a superclass accessible from subclasses using the `protected` visibility modifier §(§11.14).

  13. 11.13 To prevent class extending and method overriding using the final modifier §(§11.15).

  14. 11.14 To automatically generate boilerplate code using Lombok §(§11.16).

## 11.1 Introduction

### Key Point

  1. Object-oriented programming allows you to define new classes from existing classes. This is called inheritance.

As discussed in the preceding chapter, the procedural paradigm focuses on
designing methods, and the object-oriented paradigm couples data and methods
together into objects. Software design using the object-oriented paradigm
focuses on objects and operations on objects. The object-oriented approach
combines the power of the procedural paradigm with an added dimension that
integrates data with operations into objects.

[Inheritance](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000DF6F)
is an important and powerful feature for reusing software. Suppose you need to
define classes to model circles, rectangles, and triangles. These classes have
many common features. What is the best way to design these classes so as to
avoid redundancy and make the system easy to comprehend and easy to maintain?
The answer is to use inheritance.

## 11.2 Superclasses and Subclasses

### Key Point

  1. Inheritance enables you to define a general class (i.e., a superclass) and later extend it to more specialized classes (i.e., subclasses).

You use a class to model objects of the same type. Different classes may have
some common properties and behaviors, which can be generalized in a class that
can be shared by other classes. You can define a specialized class that
extends the generalized class. The specialized classes inherit the properties
and methods from the general class.

#### VideoNote 11.1

Geometric Class Hierarchy

![The figure illustrates the Video icon inside the dark blue box and is
labeled VIDEO.](2_files/video_icon_001.png)

Consider geometric objects. Suppose you want to design the classes to model
geometric objects such as circles and rectangles. Geometric objects have many
common properties and behaviors. They can be drawn in a certain color and be
filled or unfilled. Thus, a general class `GeometricObject` can be used to
model all geometric objects. This class contains the properties `color` and
`filled` and their appropriate getter and setter methods. Assume this class
also contains the `dateCreated` property, and the `getDateCreated()` and
`toString()` methods. The `toString()` method returns a string representation
of the object. Since a circle is a special type of geometric object, it shares
common properties and methods with other geometric objects. Thus, it makes
sense to define the `Circle` class that extends the `GeometricObject` class.
Likewise, `Rectangle` can also be defined as a special type of
`GeometricObject`. Figure 11.1 shows the relationship among these classes. A
triangular arrow pointing to the generalized class is used to denote the
inheritance relationship between the two classes involved.

#### Figure 11.1 The GeometricObject class is the superclass for Circle and
Rectangle.

![The figure illustrates an interactive that shows a set of commands for the
Geometric object package.](2_files/FG_11_001a.png)

[11.2-2 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_fg_11_001a.xhtml#la_fg_11_001a)

![The figure illustrates an interactive that shows a set of commands for the
Geometric object package.](2_files/FG_11_001b.png)

[11.2-2 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_fg_11_001b.xhtml#la_fg_11_001b)

![The figure illustrates an interactive that shows a set of commands for the
Geometric object package.](2_files/FG_11_001c.png)

[11.2-2 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_fg_11_001c.xhtml#la_fg_11_001c)

In Java terminology, a class `C1` extended from another class `C2` is called a
[subclass](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E1B3),
and `C2` is called a
[superclass](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E1BC).
A superclass is also referred to as a _parent class_ or a _base class_ , and a
subclass as a _child class_ , an _extended class_ , or a _derived class_. A
subclass inherits accessible data fields and methods from its superclass and
may also add new data fields and methods. Therefore, `Circle` and `Rectangle`
are subclasses of `GeometricObject`, and `GeometricObject` is the superclass
for `Circle` and `Rectangle`. A class defines a type. A type defined by a
subclass is called a
[subtype](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E1B9),
and a type defined by its superclass is called a
[supertype](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E1BF).
Therefore, you can say that `Circle` is a subtype of `GeometricObject`, and
`GeometricObject` is a supertype for `Circle`.

The subclass and its superclass are said to form a _is-a_ relationship. A
`Circle` object is a special type of general `GeometricObject`. The `Circle`
class inherits all accessible data fields and methods from the
`GeometricObject` class. In addition, it has a new data field, `radius`, and
its associated getter and setter methods. The `Circle` class also contains the
`getArea()`, `getPerimeter()`, and `getDiameter()` methods for returning the
area, perimeter, and diameter of the circle.

The `Rectangle` class inherits all accessible data fields and methods from the
`GeometricObject` class. In addition, it has the data fields `width` and
`height` and their associated getter and setter methods. It also contains the
`getArea()` and `getPerimeter()` methods for returning the area and perimeter
of the rectangle. Note that you may have used the terms width and length to
describe the sides of a rectangle in geometry. The common terms used in
computer science are width and height, where width refers to the horizontal
length, and height to the vertical length.

The `GeometricObject`, `Circle`, and `Rectangle` classes are shown in
LiveExample 11.1, LiveExample 11.2, and LiveExample 11.3, respectively.

#### LiveExample 11.1 GeometricObject.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](2_files/live_example_11_001.png)

#### LiveExample 11.2 Circle.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](2_files/live_example_11_002.png)

The `Circle` class (LiveExample 11.2) extends the `GeometricObject` class
(LiveExample 11.1) using the following syntax:

![The figure illustrates highlights the subclass and the superclass in a code
in a Java program.](2_files/Page_821_001.png)

[11.2-7 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_page_821_001.xhtml#la_page_821_001)

The keyword `extends` (line 1) tells the compiler that the `Circle` class
extends the `GeometricObject` class, thus inheriting the methods `getColor`,
`setColor`, `isFilled`, `setFilled`, and `toString`.

The overloaded constructor `Circle(double radius`, `String color`, `boolean
filled` `)` is implemented by invoking the `setColor` and `setFilled` methods
to set the `color` and `filled` properties (lines 14 and 15). The public
methods defined in the superclass `GeometricObject` are inherited in `Circle`,
so they can be used in the `Circle` class.

You might attempt to use the data fields `color` and `filled` directly in the
constructor as follows:

    
    
    **public** **Circle**(**double** radius, String color, boolean filled) {
      **this**.radius = radius;
      **this**.color = color; _// Illegal_
      **this**.filled = filled; _// Illegal_
    }
    

This is wrong because the private data fields `color` and `filled` in the
`GeometricObject` class cannot be accessed in any class other than in the
`GeometricObject` class itself. The only way to read and modify `color` and
`filled` is through their getter and setter methods.

The `Rectangle` class (LiveExample 11.3) extends the `GeometricObject` class
(LiveExample 11.1) using the following syntax:

![The figure illustrates highlights the subclass and the superclass in a code
in a Java program.](2_files/Page_822_001.png)

[11.2-8 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_page_822_001.xhtml#la_page_822_001)

The keyword `extends` (lines 1) tells the compiler the `Rectangle` class
extends the `GeometricObject` class, thus inheriting the methods `getColor`,
`setColor`, `isFilled`, `setFilled`, and `toString`.

#### LiveExample 11.3 Rectangle.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](2_files/live_example_11_002.png)

The code in LiveExample 11.4 creates objects of `Circle` and `Rectangle` and
invokes the methods on these objects. The `toString()` method is inherited
from the `GeometricObject` class and is invoked from a `Circle` object (line
4) and a `Rectangle` object (line 11).

#### LiveExample 11.4 TestCircleRectangle.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](2_files/live_example_11_004.png)

Note the following points regarding inheritance:

  * Contrary to the conventional interpretation, a subclass is not a subset of its superclass. In fact, a subclass usually contains more information and methods than its superclass.

  * Private data fields in a superclass are not accessible outside the class. Therefore, they cannot be used directly in a subclass. They can, however, be accessed/mutated through public accessors/mutators if defined in the superclass.

  * Not all is-a relationships should be modeled using inheritance. For example, a square is a rectangle, but you should not extend a `Square` class from a `Rectangle` class, because the `width` and `height` properties are not appropriate for a square. Instead, you should define a `Square` class to extend the `GeometricObject` class and define the `side` property for the side of a square.

  * Inheritance is used to model the is-a relationship. Do not blindly extend a class just for the sake of reusing methods. For example, it makes no sense for a `Tree` class to extend a `Person` class, even though they share common properties such as `height` and `weight`. A subclass and its superclass must have the is-a relationship.

  * Some programming languages allow you to derive a subclass from several classes. This capability is known as [multiple inheritance](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E047). Java, however, does not allow multiple inheritance. A Java class may inherit directly from only one superclass. This restriction is known as [single inheritance](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E176). If you use the `extends` keyword to define a subclass, it allows only one parent class. Nevertheless, multiple inheritance can be achieved through interfaces, which will be introduced in [Section 13.5](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000006F10.xhtml#P7001018329000000000000000006F10).

### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](2_files/self_check_11_001a.png)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](2_files/self_check_11_001b.webp)

## 11.3 Using the super Keyword

### Key Point

  1. The keyword `super` refers to the superclass and can be used to invoke the superclass's methods and constructors.

A subclass inherits accessible data fields and methods from its superclass.
Does it inherit constructors? Can the superclass’s constructors be invoked
from a subclass? This section addresses these questions and their
ramifications.

[Section
9.14](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP70010183290000000000000000050D0.xhtml#P70010183290000000000000000050D0),
The `this` Reference, introduced the use of the keyword `this` to reference
the calling object. The keyword `super` refers to the superclass of the class
in which `super` appears. It can be used in two ways:

  1. To call a superclass constructor.

  2. To reference a superclass accessible members.

### Self-Check

Use check point questions to check your understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](3_files/self_check_11_002.webp)

### 11.3.1 Calling Superclass Constructors

A constructor is used to construct an instance of a class. Unlike properties
and methods, the constructors of a superclass are not inherited by a subclass.
They can only be invoked from the constructors of the subclasses using the
keyword `super`.

The syntax to call a superclass’s constructor is:

    
    
    **super**() **or super**(arguments);
    

The statement `super()` invokes the no-arg constructor of its superclass, and
the statement `super(arguments)` invokes the superclass constructor that
matches the `arguments`. The statement `super()` or `super(arguments)` must be
the first statement of the subclass’s constructor; this is the only way to
explicitly invoke a superclass constructor. For example, the constructor in
lines 11–16 in [LiveExample
11.2](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005D87)
can be replaced by the following code:

    
    
    **public** **Circle**(**double** radius, String color, **boolean** filled) {
      **super**(color, filled);
      **this**.radius = radius;
    }
    

#### Caution

You must use the keyword `super` to call the superclass constructor, and the
call must be the first statement in the constructor. Invoking a superclass
constructor’s name in a subclass causes a syntax error.

#### Self-Check

Use multiple-choice questions to check your understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](3_files/self_check_11_003.png)

### 11.3.2 Constructor Chaining

A constructor may invoke an overloaded constructor or its superclass
constructor. If neither is invoked explicitly, the compiler automatically puts
`super()` as the first statement in the constructor. For example:

![The figure illustrates an interactive showing a Java program
code.](3_files/Page_829_001.png)

[11.3-15 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_page_829_001.xhtml#la_page_829_001)

In any case, constructing an instance of a class invokes the constructors of
all the superclasses along the inheritance chain. When constructing an object
of a subclass, the subclass constructor first invokes its superclass
constructor before performing its own tasks. If the superclass is derived from
another class, the superclass constructor invokes its parent-class constructor
before performing its own tasks. This process continues until the last
constructor along the inheritance hierarchy is called. This is called
[constructor
chaining](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000DE37).

Consider the following code:

#### Codeanimation Faculty.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](3_files/code_animation_11_001.webp)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](3_files/Page_830_001.png)

The program produces the preceding output. Why? Let us discuss the reason. In
line 3, `new Faculty()` invokes `Faculty`’s no-arg constructor. Since
`Faculty` is a subclass of `Employee`, `Employee`’s no-arg constructor is
invoked before any statements in `Faculty`’s constructor are executed.
`Employee`’s no-arg constructor invokes `Employee`’s second constructor (line
13). Since `Employee` is a subclass of `Person`, `Person`’s no-arg constructor
is invoked before any statements in `Employee`’s second constructor are
executed. This process is illustrated in the following figure.

![Four input screens show the construction chaining
codes.](3_files/Page_830_002.png)

[11.3-18 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_page_830_002.xhtml#la_page_830_002)

#### Caution

If a class is designed to be extended, it is better to provide a no-arg
constructor to avoid programming errors. Consider the following code:

    
    
    **public class** **Apple** **extends** **Fruit** {
    }
    
    **class** **Fruit** {
      **public** **Fruit**(String name) {
        System.out.println("Fruit's constructor is invoked");
      }
    }
    

Since no constructor is explicitly defined in `Apple`, `Apple`’s default no-
arg constructor is defined implicitly. Since `Apple` is a subclass of `Fruit`,
`Apple`’s default constructor automatically invokes `Fruit`’s no-arg
constructor. However, `Fruit` does not have a no-arg constructor, because
`Fruit` has an explicit constructor defined. Therefore, the program cannot be
compiled.

#### Design Guide

If possible, you should provide a no-arg constructor for every class to make
the class easy to extend and to avoid errors.

#### Self-Check

Use multiple-choice questions to check your understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](3_files/self_check_11_004.png)

### 11.3.3 Calling Superclass Methods

The keyword `super` can also be used to reference a method other than the
constructor in the superclass. The syntax is

    
    
    **super**.method(arguments);
    

You could rewrite the `printCircle()` method in the `Circle` class as follows:

    
    
    **public void** **printCircle**() {
      System.**out**.println("The circle is created " +
        super.getDateCreated() + " and the radius is " + radius);
    }
    

It is not necessary to put `super` before `getDateCreated()` in this case,
however, because `getDateCreated` is a method in the `GeometricObject` class
and is inherited by the `Circle` class. Nevertheless, in some cases, as shown
in the next section, the keyword `super` is needed.

#### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](3_files/self_check_11_005.webp)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](3_files/self_check_11_005b.webp)

## 11.4 Overriding Methods

### Key Point

  1. To override a method, the method must be defined in the subclass using the same signature as in its superclass.

A subclass inherits methods from a superclass. Sometimes, it is necessary for
the subclass to modify the implementation of a method defined in the
superclass. This is referred to as [method
overriding](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E034).

The `toString` method in the `GeometricObject` class (lines 46–49 in
[LiveExample
11.1](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005D82))
returns the string representation of a geometric object. This method can be
overridden to return the string representation of a circle. To
[override](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E08C)
it, add the following new method in the `Circle` class in [LiveExample
11.2](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005D87):

    
    
    1 **public class** **Circle** **extends** **GeometricObject** {
    2   _// Other methods are omitted_
    3
    
    4   _// Override the toString method defined in the superclass_
    5   **public** String **toString**() {
    6     **return super**.toString() + "\nradius is " + radius;
    7   }
    8 }
    

The `toString()` method is defined in the `GeometricObject` class and modified
in the `Circle` class. Both methods can be used in the `Circle` class. To
invoke the `toString` method defined in the `GeometricObject` class from the
`Circle` class, use `super.toString()` (line 6).

Can a subclass of `Circle` access the `toString` method defined in the
`GeometricObject` class using syntax such as `super.super.toString()`? No.
This is a syntax error.

Several points are worth noting:

  * The overriding method must have the same signature as the overridden method and same or compatible return type. Compatible means that the overriding method’s return type is a subtype of the overridden method’s return type.

  * An instance method can be overridden only if it is accessible. Thus, a private method cannot be overridden, because it is not accessible outside its own class. If a method defined in a subclass is private in its superclass, the two methods are completely unrelated.

  * Like an instance method, a static method can be inherited. However, a static method cannot be overridden. If a static method defined in the superclass is redefined in a subclass, the method defined in the superclass is hidden. The hidden static methods can be invoked using the syntax `SuperClassName.staticMethodName`.

### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](4_files/self_check_11_006a.webp)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](4_files/self_check_11_006b.webp)

## 11.5 Overriding vs. Overloading

### Key Point

  1. Overloading means to define multiple methods with the same name but different signatures. Overriding means to provide a new implementation for a method in the subclass.

You learned about overloading methods in [Section
6.8](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP70010183290000000000000000036A5.xhtml#P70010183290000000000000000036A5).
To override a method, the method must be defined in the subclass using the
same signature and the same or compatible return type.

Let us use an example to show the differences between overriding and
overloading. In `TestOverriding` below, the method `p(double i)` in class `A`
overrides the same method defined in class `B`. In `TestOverloading` below,
however, the class `A` has two overloaded methods: `p(double i)` and `p(int
i)`. The method `p(double i)` is inherited from `B`.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](5_files/Page_837_001.webp)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](5_files/Page_838_001.png)

When you run the `TestOverriding` class, both `a.p(10)` and `a.p(10.0)` invoke
the `p(double i)` method defined in class `A` to display `10.0`. When you run
the `TestOverloading` class, `a.p(10)` invokes the `p(int i)` method defined
in class `A` to display `10` and `a.p(10.0)` invokes the `p(double i)` method
defined in class `B` to display `20.0`.

Note the following:

  * Overridden methods are in different classes related by inheritance; overloaded methods can be either in the same class, or in different classes related by inheritance.

  * Overridden methods have the same signature; overloaded methods have the same name but different parameter lists.

To avoid mistakes, you can use a special Java syntax, called override
annotation, to place `@Override` before the overriding method in the subclass.
For example,

    
    
    1 **public class** **Circle** **extends** **GeometricObject** {
    2   _// Other methods are omitted_
    3
    4   **@Override**
    5   **public** String **toString**() {
    6     **return super**.toString() + "\nradius is " + radius;
    7   }
    8 }
    

This annotation denotes that the annotated method is required to override a
method in its superclass. If a method with this annotation does not override
its superclass’s method, the compiler will report an error. For example, if
`toString` is mistyped as `tostring`, a compile error is reported. If the
`@Override` annotation isn’t used, the compiler won’t report an error. Using
the `@Override` annotation avoids mistakes.

### Self-Check

Use check point questions, word match, and multiple-choice questions to check
your understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](5_files/self_check_11_007a.png)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](5_files/self_check_11_007b.png)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](5_files/self_check_11_007c.png)

## 11.6 The `Object` Class and Its `toString()` Method

### Key Point

  1. Every class in Java is descended from the `java.lang.Object` class.

If no inheritance is specified when a class is defined, the superclass of the
class is `Object` by default. For example, the following two class definitions
in (a) and (b) are the same:

![The figure illustrates an interactive showing the omission of an object in a
code of a Java program.](6_files/Page_843_001.webp)

[11.6-29 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_page_843_001.xhtml#la_page_843_001)

Classes such as `String`, `StringBuilder`, `Loan`, and `GeometricObject` are
implicitly subclasses of `Object` (as are all the main classes you have seen
in this book so far). It is important to be familiar with the methods provided
by the `Object` class so that you can use them in your classes. This section
introduces the `toString` method in the `Object` class.

The signature of the `toString()` method is:

    
    
    **public** String toString()
    

Invoking `toString()` on an object returns a string that describes the object.
By default, it returns a string consisting of a class name of which the object
is an instance, an at sign `(`@`)`, and the object’s memory address in
hexadecimal. For example, consider the following code for the `Loan` class
defined in [LiveExample
10.2](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP70010183290000000000000000053BA.xhtml#P7001018329000000000000000005403):

    
    
    Loan loan = **new** Loan();
    System.**out**.println(loan.toString());
    

The output for this code displays something like `Loan@15037e5`. This message
is not very helpful or informative. Usually you should override the `toString`
method so that it returns a descriptive string representation of the object.
For example, the `toString` method in the `Object` class was overridden in the
`GeometricObject` class in lines 46–49 in [LiveExample
11.1](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005D82)
as follows:

    
    
    **public** String **toString**() {
      **return** "created on " + dateCreated + "\ncolor: " + color +
        " and filled: " + filled;
    }
    

#### Note

You can also pass an object to invoke `System.out.println(object)` or
`System.out.print(object)`. This is equivalent to invoking
`System.out.println(object.toString())` or
`System.out.print(object.toString())`. Thus, you could replace
`System.out.println(loan.toString())` with `System.out.println(loan)`.

### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](6_files/self_check_11_008a.webp)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](6_files/self_check_11_008b.webp)

## 11.7 Polymorphism

### Key Point

  1. Polymorphism means that a variable of a supertype can refer to a subtype object.

The three pillars of object-oriented programming are encapsulation,
inheritance, and polymorphism. You have already learned the first two. This
section introduces polymorphism.

The inheritance relationship enables a subclass to inherit features from its
superclass with additional new features. A subclass is a specialization of its
superclass; every instance of a subclass is also an instance of its
superclass, but not vice versa. For example, every circle is a geometric
object, but not every geometric object is a circle. Therefore, you can always
pass an instance of a subclass to a parameter of its superclass type. Consider
the code in LiveExample 11.5.

#### LiveExample 11.5 PolymorphismDemo.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](7_files/live_example_11_005.webp)

The method `displayObject` (line 10) takes a parameter of the
`GeometricObject` type. You can invoke `displayObject` by passing any instance
of `GeometricObject` (e.g., `new Circle(1, "red", false)` and `new
Rectangle(1, 1, "black", true)` in lines 5 and 6). An object of a subclass can
be used wherever its superclass object is used. This is commonly known as
[polymorphism](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E0AB)
(from a Greek word meaning “many forms”). In simple terms, polymorphism means
that a variable of a supertype can refer to a subtype object.

### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](7_files/self_check_11_009a.png)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](7_files/self_check_11_009b.webp)

## 11.8 Dynamic Binding

### Key Point

  1. A method can be implemented in several classes along the inheritance chain. The JVM decides which method is invoked at runtime.

#### VideoNote 11.2

Polymorphism and Dynamic Binding Demo

![The figure illustrates the Video icon inside the dark blue box and is
labeled VIDEO.](8_files/video_icon_001.png)

A method can be defined in a superclass and overridden in its subclass. For
example, the `toString()` method is defined in the `Object` class and
overridden in `GeometricObject`. Consider the following code:

    
    
    Object o = **new** GeometricObject();
    System.**out**.println(o.toString());
    

Which `toString()` method is invoked by `o`? To answer this question, we first
introduce two terms: declared type and actual type. A variable must be
declared a type. The type that declares a variable is called the variable’s
[declared
type](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000DE5B).
Here, `o`’s declared type is `Object`. A variable of a reference type can hold
a `null` value or a reference to an instance of the declared type. The
instance may be created using the constructor of the declared type or its
subtype. The [actual
type](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000DD2E)
of the variable is the actual class for the object referenced by the variable
at runtime. Here, `o`’s actual type is `GeometricObject`, because `o`
references an object created using `new GeometricObject()`. Which `toString()`
method is invoked by o is determined by o’s actual type. This is known as
[dynamic
binding](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000DEA7).

Dynamic binding works as follows: Suppose that an object `o` is an instance of
classes `C1`, `C2`, . . . , `Cn-1`, and `Cn`, where `C1` is a subclass of
`C2`, `C2` is a subclass of `C3`, . . . , and `Cn-1` is a subclass of `Cn`, as
shown in Figure 11.2. That is, `Cn` is the most general class, and `C1` is the
most specific class. In Java, `Cn` is the `Object` class. If `o` invokes a
method `p`, the JVM searches for the implementation of the method `p` in `C1`,
`C2`, . . . , `Cn-1`, and `Cn`, in this order, until it is found. Once an
implementation is found, the search stops and the first-found implementation
is invoked.

#### Figure 11.2 The method to be invoked is dynamically bound at runtime.

![The figure illustrates a block diagram for the java dot lang
package.](8_files/FG_11_002.webp)

[Figure 11.2 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_fg_11_002.xhtml#la_fg_11_002)

LiveExample 11.6 gives an example to demonstrate dynamic binding.

#### LiveExample 11.6 DynamicBindingDemo.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](8_files/live_example_11_006.webp)

Method `m` (line 9) takes a parameter of the `Object` type. You can invoke `m`
with any object (e.g., `new GraduateStudent()`, `new Student()`, `new
Person()`, and `new Object()` in lines 3–6).

When the method `m(Object x)` is executed, the argument `x`’s `toString`
method is invoked. `x` may be an instance of `GraduateStudent`, `Student`,
`Person`, or `Object`. The `toString` method is implemented in `Student`,
`Person`, and `Object`. Which implementation is used will be determined by
`x`’s actual type at runtime. Invoking `m(new GraduateStudent())` (line 3)
causes the `toString` method defined in the `Student` class to be invoked.

Invoking `m(new Student())` (line 4) causes the `toString` method defined in
the `Student` class to be invoked; invoking `m(new Person())` (line 5) causes
the `toString` method defined in the `Person` class to be invoked; and
invoking `m(new Object())` (line 6) causes the `toString` method defined in
the `Object` class to be invoked.

Matching a method signature and binding a method implementation are two
separate issues. The _declared type_ of the reference variable decides which
method to match at compile time. The compiler finds a matching method
according to the parameter type, number of parameters, and order of the
parameters at compile time. A method may be implemented in several classes
along the inheritance chain. The JVM dynamically binds the implementation of
the method at runtime, decided by the actual type of the variable.

### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](8_files/self_check_11_010a.webp)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](8_files/self_check_11_010b.webp)

## 11.9 Casting Objects and the `instanceof` Operator

### Key Point

  1. One object reference can be typecast into another object reference. This is called casting object.

In the preceding section, the statement

    
    
    m(**new** Student());
    

assigns the object `new Student()` to a parameter of the `Object` type. This
is called [casting
object](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000DDE5).
This statement is equivalent to.

    
    
    Object o = **new** Student(); _// Implicit casting_
    m(o);
    

The statement `Object o = new Student()`, known as _implicit casting_ , is
legal because an instance of `Student` is an instance of `Object`.

Suppose you want to assign the object reference o to a variable of the
`Student` type using the following statement:

    
    
    Student b = o;
    

In this case a compile error would occur. Why does the statement `Object o =
new Student()` work, but `Student b = o` doesn’t? The reason is that a
`Student` object is always an instance of `Object`, but an `Object` is not
necessarily an instance of `Student`. Even though you can see that `o` is
really a `Student` object, the compiler is not clever enough to know it. To
tell the compiler `o` is a `Student` object, use _explicit casting_. The
syntax is similar to the one used for casting among primitive data types.
Enclose the target object type in parentheses and place it before the object
to be cast, as follows:

    
    
    Student b = (Student)o; _// Explicit casting_
    

It is always possible to cast an instance of a subclass to a variable of a
superclass (known as _upcasting_) because an instance of a subclass is
_always_ an instance of its superclass. When casting an instance of a
superclass to a variable of its subclass (known as _downcasting_), explicit
casting must be used to confirm your intention to the compiler with the
`(SubclassName)` cast notation. For the casting to be successful, you must
make sure the object to be cast is an instance of the subclass. If the
superclass object is not an instance of the subclass, a runtime
`_ClassCastException_` occurs. For example, if an object is not an instance of
`Student`, it cannot be cast into a variable of `Student`. It is a good
practice, therefore, to ensure the object is an instance of another object
before attempting a casting. This can be accomplished by using the
[instanceof](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000DF85)
operator. Consider the following code:

    
    
    **void** **someMethod**(Object myObject) {
      ... _// Some lines of code_
      _/** Perform casting if myObject is an instance of Circle */_
      **if** (myObject instanceof Circle) {
        System.out.println("The circle diameter is " +
          ((Circle)myObject).getDiameter());
        ...
      }
    }
    

You may be wondering why casting is necessary. The variable `myObject` is
declared `Object`. The _declared type_ decides which method to match at
compile time. Using `myObject.getDiameter()` would cause a compile error,
because the `Object` class does not have the `getDiameter` method. The
compiler cannot find a match for `myObject.getDiameter()`. Therefore, it is
necessary to cast `myObject` into the `Circle` type to tell the compiler that
`myObject` is also an instance of `Circle`.

Why not declare `myObject` as a `Circle` type in the first place? To enable
generic programming, it is a good practice to declare a variable with a
supertype that can accept an object of any subtype.

#### Note

`instanceof` is a Java keyword. Every letter in a Java keyword is in
lowercase.

#### Tip

To help understand casting, you may also consider the analogy of fruit, apple,
and orange, with the `Fruit` class as the superclass for `Apple` and `Orange`.
An apple is a fruit, so you can always safely assign an instance of `Apple` to
a variable for `Fruit`. However, a fruit is not necessarily an apple, so you
have to use explicit casting to assign an instance of `Fruit` to a variable of
`Apple`.

LiveExample 11.7 demonstrates polymorphism and casting. The program creates
two objects (lines 5 and 6), a `circle` and a `rectangle`, and invokes the
`displayObject` method to display them (lines 9 and 10). The `displayObject`
method displays the area and diameter if the object is a circle (line 15), and
the area if the object is a rectangle (line 21).

#### LiveExample 11.7 CastingDemo.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](9_files/live_example_11_007.webp)

The `displayObject(Object object)` method is an example of generic
programming. It can be invoked by passing any instance of `Object`.

The program uses implicit casting to assign a `Circle` object to `object1` and
a `Rectangle` object to `object2` (lines 5 and 6), then invokes the
`displayObject` method to display the information on these objects (lines
9–10).

In the `displayObject` method (lines 14–25), explicit casting is used to cast
the object to `Circle` if the object is an instance of `Circle`, and the
methods `getArea` and `getDiameter` are used to display the area and diameter
of the circle.

Casting can be done only when the source object is an instance of the target
class. The program uses the `instanceof` operator to ensure that the source
object is an instance of the target class before performing a casting (lines
15 and 21).

Explicit casting to `Circle` (lines 17 and 19) and to `Rectangle` (line 23) is
necessary because the `getArea` and `getDiameter` methods are not available in
the `Object` class.

#### Caution

The object member access operator (.) has higher precedence than the casting
operator. Use parentheses to ensure that casting is done before the .
operator, as in

    
    
    ((Circle)object).getArea()
    

When using the if statement to test if an object is an instance of a class,
you can specify a _binding variable_. If the result of the `instanceof`
operator is true, then the object being tested is assigned to the binding
variable. This new syntax, known as _instanceof pattern matching_ , became a
standard feature since Java 16. You can simplify the code in lines 15-24 using
this new feature as follows:

    
    
    1  **if** (myObject instanceof Circle circle) {
    2    System.**out**.println("The circle area is " +
    3      circle.getArea());
    4    System.**out**.println("The circle diameter is " +
    5      circle.getDiameter());
    6  }
    7  **else if** (myObject instanceof Rectangle rectangle) {
    8    System.**out**.println("The rectangle area is " +
    9      rectangle.getArea());
    10  }
    

If `object` is an instance of `Circle`, `object` is assigned to binding
variable `circle` in line 1. You can then invoke `circle.getArea()` and
`circle.getDiameter()` without having to cast object to `Circle`. This new
language feature simplifies coding.

Casting a primitive-type value is different from casting an object reference.
Casting a primitive-type value returns a new value. For example:

    
    
    **int** age = 45;
    **byte** newAge = (**byte**)age; _// A new value is assigned to newAge_
    

However, casting an object reference does not create a new object. For
example:

    
    
    Object o = **new** Circle();
    Circle c = (Circle)o; // No **new** object **is** created
    

Now, reference variables `o` and `c` point to the same object.

### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](9_files/self_check_11_011a.webp)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](9_files/self_check_11_011b.png)

## 11.10 The Object’s equals Method

### Key Point

  1. Like the `toString()` method, the `equals(Object)` method is another useful method defined in the `Object` class.

Another method defined in the `Object` class that is often used is the
`equals` method. Its signature is

    
    
    **public boolean** **equals**(Object o)
    

This method tests whether two objects are equal. The syntax for invoking it is

    
    
    **object1**.equals(**object2**);
    

The default implementation of the `equals` method in the `Object` class is

    
    
    **public boolean** **equals**(Object o) {
      **return this** == o;
    }
    

This implementation checks whether two reference variables point to the same
object using the **`==`** operator. You should override this method in your
custom class to test whether two distinct objects have the same content.

The `equals` method is overridden in many classes in the Java API, such as
`java.lang.String` and `java.util.Date`, to compare whether the contents of
two objects are equal. You have already used the `equals` method to compare
two strings in [Section
4.4.7](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000002428.xhtml#P700101832900000000000000000254A),
The `String` Class. The `equals` method in the `String` class is inherited
from the `Object` class, and is overridden in the `String` class to test
whether two strings are identical in content.

You can override the `equals` method in the `Circle` class to compare whether
two circles are equal based on their radius as follows:

    
    
    **@Override**
    **public boolean** **equals**(Object o) {
      **if** (o **instanceof** Circle)
        **return** radius == ((Circle)o).radius;
      **else**
        **return false** ;
    }
    

#### Note

The **`==`** comparison operator is used for comparing two primitive-data-type
values or for determining whether two objects have the same references. The
`equals` method is intended to test whether two objects have the same
contents, provided the method is overridden in the defining class of the
objects. The `==` operator is stronger than the `equals` method in that the
`==`operator checks whether the two reference variables refer to the same
object.

#### Caution

Using the signature `equals(SomeClassName o)` (e.g., `equals(Circle c)`) to
override the `equals` method in a subclass is a common mistake. You should use
`equals(Object o)`. See CheckPoint Question 11.10.2.

### Self-Check

Use check point questions, freestyle exercises, and multiple-choice questions
to check your understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](10_files/self_check_11_012a.png)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](10_files/self_check_11_012b.png)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](10_files/self_check_11_013a.png)

## 11.11 The ArrayList Class

### Key Point

  1. An `ArrayList` object can be used to store a list of objects.

Now we are ready to introduce a very useful class for storing objects. You can
create an array to store objects. However, once the array is created, its size
is fixed. Java provides the `ArrayList` class, which can be used to store an
unlimited number of objects. Figure 11.3 shows some methods in `ArrayList`.

#### Figure 11.3 An `ArrayList` stores an unlimited number of objects.

![The figure illustrates an interactive that shows a set of commands for the
java dot util dot ArrayList package.](11_files/FG_11_003.webp)

[Figure 11.3 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_fg_11_003.xhtml#la_fg_11_003)

`ArrayList` is known as a generic class with a generic type `E`. You can
specify a concrete type to replace `E` when creating an `ArrayList`. For
example, the following statement creates an `ArrayList` and assigns its
reference to variable `cities`. This `ArrayList` object can be used to store
strings.

    
    
    ArrayList<String> cities = **new** ArrayList<String>();
    

The following statement creates an `ArrayList` and assigns its reference to
variable `dates`. This `ArrayList` object can be used to store dates.

    
    
    ArrayList<java.util.Date> dates = new ArrayList<java.util.Date>();
    

#### Note

Since JDK 7, the statement

    
    
    ArrayList<AConcreteType> **list** = **new** ArrayList<AConcreteType>();
    

can be simplified by

    
    
    ArrayList<AConcreteType> **list** = **new** ArrayList<>();
    

The concrete type is no longer required in the constructor, thanks to a
feature called [type
inference](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E1F8).
The compiler is able to infer the type from the variable declaration. More
discussions on generics including how to define custom generic classes and
methods will be introduced in [Chapter
19](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000971C.xhtml#P700101832900000000000000000971C),
Generics.

The following animation shows the working of some `ArrayList` methods.

#### Animation `ArrayList` Methods

![The figure illustrates an interactive showing a string followed by a few
questions.](11_files/animation_11_01.png)

[11.11-45 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_animation_11_01.xhtml#la_animation_11_01)

LiveExample 11.8 gives an example of using `ArrayList` to store objects.

#### LiveExample 11.8 TestArrayList.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](11_files/live_example_11_008.webp)

Since the `ArrayList` is in the `java.util` package, it is imported in line 1.
The program creates an `ArrayList` of strings using its no-arg constructor and
assigns the reference to `cityList` (line 6). The `add` method (lines 9–19)
adds strings to the end of list. Thus, after `cityList.add("London")` (line
9), the list contains

    
    
    [London]
    

After `cityList.add("Denver")` (line 11), the list contains

    
    
    [London, Denver]
    

After adding `Paris`, `Miami`, `Seoul`, and `Tokyo` (lines 13–19), the list
contains

    
    
    [London, Denver, Paris, Miami, Seoul, Tokyo]
    

Invoking `size()` (line 22) returns the size of the list, which is currently
`6`. Invoking `contains("Miami")` (line 24) checks whether the object is in
the list. In this case, it returns `true`, since `Miami` is in the list.
Invoking `indexOf("Denver")` (line 26) returns the index of `Denver` in the
list, which is `1`. If `Denver` were not in the list, it would return `–1`.
The `isEmpty()` method (line 28) checks whether the list is empty. It returns
`false`, since the list is not empty.

The statement `cityList.add(2, "Xian")` (line 31) inserts an object into the
list at the specified index. After this statement, the list becomes

    
    
    [London, Denver, Xian, Paris, Miami, Seoul, Tokyo]
    

The statement `cityList.remove("Miami")` (line 35) removes the object from the
list. After this statement, the list becomes

    
    
    [London, Denver, Xian, Paris, Seoul, Tokyo]
    

The statement `cityList.remove(1)` (line 39) removes the object at the
specified index from the list. After this statement, the list becomes

    
    
    [London, Xian, Paris, Seoul, Tokyo]
    

The statement in line 43 is same as

    
    
    **System**.out.println(**cityList**);
    

The `toString()` method returns a string representation of the list in the
form of `[e0.toString(), e1.toString(), ..., ek.toString()]`, where `e0`,
`e1`, ..., and `ek` are the elements in the list.

The `get(index)` method (line 47) returns the object at the specified index.

### Self-Check

Use check point questions, word match, freestyle exercises, and multiple-
choice questions to check your understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](11_files/self_check_11_014a.png) ![This is an
interactive asset. Students who wish to access this must log in to Pearson+
for the etext.](11_files/self_check_11_014b.png)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](11_files/self_check_11_014c.png)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](11_files/self_check_11_014d.webp)

### 11.11.1 ArrayList vs. Array

`ArrayList` objects can be used like arrays, but there are many differences.
Table 11.1 lists their similarities and differences.

#### Table 11.1 Differences and Similarities between Arrays and `ArrayList`

 _Operation_ | _Array_ | _ArrayList_  
---|---|---  
Creating an array/ArrayList | `String[] a = new String[10]` | `ArrayList<String> list = **new** ArrayList<>();`  
Accessing an element | `a[index]` | `list.get(index);`  
Updating an element | `a[index] = "London";` | `list.set(index, "London");`  
Returning size | ﻿`a.length`﻿ | `list.size();`  
Adding a new element |  | `list.add("London");`  
Inserting a new element |  | `list.add(index, "London");`  
Removing an element |  | `list.remove(index);`  
Removing an element |  | `list.remove(Object);`  
Removing all elements |  | ﻿`list.clear();﻿`﻿  
  
Once an array is created, its size is fixed. You can access an array element
using the square-bracket notation (e.g., `a[index]`). When an `ArrayList` is
created, its size is `0`. You cannot use the `get(index)` and `set(index,
element)` methods if the index is out of range. It is easy to add, insert, and
remove elements in a list, but it is rather complex to add, insert, and remove
elements in an array. You have to write code to manipulate the array in order
to perform these operations. Note you can sort an array using the
`java.util.Arrays.sort(array)` method. To sort an array list, use the
`java.util.Collections.sort(arraylist)` method.

Suppose you want to create an `ArrayList` for storing integers. Can you use
the following code to create a list?

    
    
    ArrayList<int> listOfIntegers = new ArrayList<>();
    

No. This will not work because the elements stored in an `ArrayList` must be
of an object type. You cannot use a primitive data type such as `int` to
replace a generic type. However, you can create an `ArrayList` for storing
`Integer` objects as follows:

    
    
    ArrayList<Integer> listOfIntegers = new ArrayList<>();
    

Note the `remove(int index)` method removes an element at the specified index.
To remove an integer value v from `listOfIntegers`, you need to use
`listOfIntegers.remove(Integer.valueOf(v))`. This is not a good design in the
Java API because it could easily lead to mistakes. It would be much better if
`remove(int)` were renamed `removeAt(int)`.

LiveExample 11.9 gives a program that prompts the user to enter a sequence of
numbers and displays the distinct numbers in the sequence. Assume the input
ends with `0`, and `0` is not counted as a number in the sequence.

#### LiveExample 11.9 DistinctNumbers.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](11_files/live_example_11_009.webp)

The program creates an `ArrayList` for `Integer` objects (line 6) and
repeatedly reads a value in the loop (lines 12–17). For each value, if it is
not in the list (line 15), add it to the list (line 16). You can rewrite this
program using an array to store the elements rather than using an `ArrayList`.
However, it is simpler to implement this program using an `ArrayList` for two
reasons.

  1. The size of an `ArrayList` is flexible so you don’t have to specify its size in advance. When creating an array, its size must be specified.

  2. `ArrayList` contains many useful methods. For example, you can test whether an element is in the list using the `contains` method. If you use an array, you have to write additional code to implement this method.

You can traverse the elements in an array using a foreach loop. The elements
in an array list can also be traversed using a foreach loop using the
following syntax:

    
    
    **for** (elementType element: arrayList) {
      _// Process the element_
    }
    

For example, you can replace the code in lines 21 and 22 using the following
code:

    
    
    **for** (Integer number: **list**)
      System.out.**print**(number + " ");
    

or

    
    
    **for** (int number: **list**)
      System.out.**print**(number + " ");
    

Note the elements in `list` are `Integer` objects. They are automatically
unboxed into int in this foreach loop.

#### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](11_files/self_check_11_015a.webp)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](11_files/self_check_11_015b.webp)

## 11.12 Useful Methods for Lists

### Key Point

  1. Java provides the methods for creating a list from an array, for sorting a list, and for finding maximum and minimum element in a list, and for shuffling a list.

Often you need to create an array list from an array of objects or vice versa.
You can write the code using a loop to accomplish this, but an easy way is to
use the methods in the Java API. Here is an example to create an array list
from an array:

    
    
    String[] **array** = {"red", "green", "blue"};
    ArrayList<String> **list** = **new** ArrayList<>(Arrays.asList(**array**));
    

The static method `asList` in the `Arrays` class returns a list that is passed
to the `ArrayList` constructor for creating an `ArrayList`. Conversely, you
can use the following code to create an array of objects from an array list:

    
    
    String[] array1 = **new** String[**list**.size()];
    **list**.toArray(array1);
    

Invoking `list.toArray(array1)` copies the contents from `list` to `array1`.
If the elements in a list are comparable, such as integers, double, or
strings, you can use the static `sort` method in the `java.util.Collections`
class to sort the elements. Here are some examples:

    
    
    Integer[] array = {3, 5, 95, 4, 15, 34, 3, 6, 5};
    ArrayList<Integer> list = **new** ArrayList<>(Arrays.asList(array));
    java.util.Collections.sort(list);
    System.**out**.println(list);
    

You can use the static `max` and `min` in the `java.util.Collections` class to
return the maximum and minimal element in a list. Here are some examples:

    
    
    Integer[] array = {3, 5, 95, 4, 15, 34, 3, 6, 5};
    ArrayList<Integer> list = **new** ArrayList<>(Arrays.asList(array));
    System.**out**.println(java.util.Collections.max(list));
    System.**out**.println(java.util.Collections.min(list));
    

You can use the static `shuffle` method in the `java.util.Collections` class
to perform a random shuffle for the elements in a list. Here are some
examples:

    
    
    Integer[] array = {3, 5, 95, 4, 15, 34, 3, 6, 5};
    ArrayList<Integer> list = **new** ArrayList<>(Arrays.asList(array));
    java.util.Collections.shuffle(list);
    System.**out**.println(list);
    

### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](12_files/self_check_11_016a.png)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](12_files/self_check_11_016b.webp)

## 11.13 Case Study: A Custom Stack Class

### Key Point

  1. This section designs a stack class for holding objects.

[Section
10.6](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000554E.xhtml#P700101832900000000000000000554E)
presented a stack class for storing `int` values. This section introduces a
stack class to store objects. You can use an `ArrayList` to implement
`MyStack`, as shown in LiveExample 11.10. The UML diagram for the class is
shown in Figure 11.4.

#### Figure 11.4 The `MyStack` class encapsulates the stack storage and
provides the operations for manipulating the stack.

![The figure illustrates an interactive of a set of commands for the MyStack
package.](13_files/FG_11_004.webp)

[Figure 11.4 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_fg_11_004.xhtml#la_fg_11_004)

#### LiveExample 11.10 MyStack.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](13_files/live_example_11_010.webp)

An array list is created to store the elements in the stack (line 4). The
`isEmpty()` method (lines 6–8) returns `list.isEmpty()`. The `getSize()`
method (lines 10–12) returns `list.size()`. The `peek()` method (lines 14–16)
retrieves the element at the top of the stack without removing it. The end of
the list is the top of the stack. The `pop()` method (lines 18–22) removes the
top element from the stack and returns it. The `push(Object o)` method (lines
24–26) adds the specified element to the stack. The `toString()` method (lines
28–31) defined in the `Object` class is overridden to display the contents of
the stack by invoking `list.toString()`. The `toString()` method implemented
in `ArrayList` returns a string representation of all the elements in an array
list.

#### Design Guide

In LiveExample 11.10, `MyStack` contains `ArrayList`. The relationship between
`MyStack` and `ArrayList` is _composition_. Composition essentially means
declaring an instance variable for referencing an object. This object is said
to be composed. While inheritance models an [is-a
relationship](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000DF9D),
composition models a _has-a_ relationship. You could also implement``
`MyStack` as a subclass of `ArrayList` (see [Programming Exercise
11.10](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP70010183290000000000000000063DC.xhtml#P7001018329000000000000000006496)).
Using composition is better, however, because it enables you to define a
completely new stack class without inheriting the unnecessary and
inappropriate methods from `ArrayList`.

### Self-Check

Use check point questions to check your understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](13_files/self_check_11_017.png)

## 11.14 The `Protected` Data and Methods

### Key Point

  1. A protected member of a class can be accessed from a subclass.

So far you have used the `private` and `public` keywords to specify whether
data fields and methods can be accessed from outside of the class. Private
members can be accessed only from inside of the class, and public members can
be accessed from any other classes.

Often it is desirable to allow subclasses to access data fields or methods
defined in the superclass, but not to allow nonsubclasses in different
packages to access these data fields and methods. To accomplish this, you can
use the
[protected](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000DD10.xhtml#P700101832900000000000000000E0EA)
keyword. This way you can access protected data fields or methods in a
superclass from its subclasses.

The modifiers `private`, `protected`, and `public` are known as _visibility_
or _accessibility modifiers_ because they specify how classes and class
members are accessed. The visibility of these modifiers increases in this
order:

→private, default (no modifier), protected, publicVisibility increases

Table 11.2 summarizes the accessibility of the members in a class. Figure 11.5
illustrates how a public, protected, default, and private datum or method in
class `C1` can be accessed from a class `C2` in the same package, a subclass
`C3` in the same package, a subclass `C4` in a different package, and a class
`C5` in a different package.

#### Table 11.2 Data and Methods Visibility

_Modifier on Members in a Class_ | _Accessed from the Same Class_ | _Accessed from the Same Package_ | _Accessed from a Subclass in a Different Package_ | _Accessed from a Different Package_  
---|---|---|---|---  
Public | **✓** | **✓** | **✓** | **✓**  
Protected | **✓** | **✓** | **✓** | **–**  
Default (no modifier) | **✓** | **✓** | **–** | **–**  
Private | **✓** | **–** | **–** | **–**  
  
#### Figure 11.5 Visibility modifiers are used to control how data and methods
are accessed.

![A set of five code diagrams displays visibility modifiers which are divided
into two groups.](14_files/FG_11_005.webp)

[Figure 11.5 Full Alternative
Text](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/longalt/la_fg_11_005.xhtml#la_fg_11_005)

Use the `private` modifier to hide the members of the class completely so they
cannot be accessed directly from outside the class. Use no modifiers (the
default) in order to allow the members of the class to be accessed directly
from any class within the same package but not from other packages. Use the
`protected` modifier to enable the members of the class to be accessed by the
subclasses in any package or classes in the same package. Use the `public`
modifier to enable the members of the class to be accessed by any class.

Your class can be used in two ways: (1) for creating instances of the class
and (2) for defining subclasses by extending the class. Make the members
`private` if they are not intended for use from outside the class. Make the
members `public` if they are intended for the users of the class. Make the
fields or methods `protected` if they are intended for the extenders of the
class but not for the users of the class.

The `private` and `protected` modifiers can be used only for members of the
class. The `public` modifier and the default modifier (i.e., no modifier) can
be used on members of the class as well as on the class. A class with no
modifier (i.e., not a public class) is not accessible by classes from other
packages.

#### Note

A subclass may override a protected method defined in its superclass and
change its visibility to public. However, a subclass cannot weaken the
accessibility of a method defined in the superclass. For example, if a method
is defined as public in the superclass, it must be defined as public in the
subclass.

### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](14_files/self_check_11_018a.webp)

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](14_files/self_check_11_018b.png)

## 11.15 Preventing Extending and Overriding

### Key Point

  1. A final class cannot be extended. A final method cannot be overridden. A final data field is a constant.

You may occasionally want to prevent classes from being extended. In such
cases, use the `final` modifier to indicate a class is final and cannot be a
parent class. The `Math` class is a final class. The `String`,
`StringBuilder`, and `StringBuffer` classes, and all wrapper classes for
primitive data types are also final classes. For example, the following class
`A` is final and cannot be extended:

    
    
    **public final class** **A** {
      _// Data fields, constructors, and methods omitted_
    }
    

You also can define a method to be final; a final method cannot be overridden
by its subclasses.

For example, the following method `m` is final and cannot be overridden:

    
    
    **public class** **Test** {
      _// Data fields, constructors, and methods omitted_
      **public final void** **m**() {
        _// Do something_
      }
    }
    

#### Note

The modifiers `public`, `protected`, `private`, `static`, `abstract`, and
`final` are used on classes and class members (data and methods), except that
the final modifier can also be used on local variables in a method. A final
local variable is a constant inside a method.

### Self-Check

Use check point questions, word match, and multiple-choice questions to check
your understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](15_files/self_check_11_019a.webp) ![This is an
interactive asset. Students who wish to access this must log in to Pearson+
for the etext.](15_files/self_check_11_019b.webp)

## 11.16 Lombok: Generating Boilerplate Code Using Annotations

When you write Java code, there are a lot of boilerplate code such as getter
and setter methods. It is tedious to write all these boilerplate code. Project
Lombok comes to rescue. Project Lombok is a Java library that provides
annotations to tell the Java compiler to automatically generate boilerplate
code such as getter and setter methods for data fields. To use Lombok, you
need download a jar file named **lombok.jar** from
`https://projectlombok.org/download`.

Here is the example of rewriting the `Rectangle` class in [LiveExample
11.3](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005DCB)
using lombok annotations.

### LiveExample 11.11 TestLombok.java

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](16_files/live_example_11_011.png)

You need to import the lombok library (line 1) in order to use the lombok
annotations in the code. The `@NoArgsConstructor` annotation (line 3)
generates a no-arg constructor with an empty body for the `Rectangle` class.
The `@ToString` annotation (line 4) generates a `toString()` method that
returns a string representation for a `Rectangle` object. The `@Getter` and
`@Setter` annotations (line 6) generate a getter method and a setter method
for data field `width`. The `@Getter` and `@Setter` annotations (line 7)
generate a getter method and a setter method for data field `height`.

To compile your code from the command line, add **lombok.jar** to the
classpath. You can also add **lombok.jar** in an IDE and use Lombok from an
IDE.

Lombok has many useful annotations you can use to simplify coding. For all
Lombok features, see `https://projectlombok.org/features/all`.

### Self-Check

Use check point questions and multiple-choice questions to check your
understanding of the concepts.

![This is an interactive asset. Students who wish to access this must log in
to Pearson+ for the etext.](16_files/self_check_11_020a.png) ![This is an
interactive asset. Students who wish to access this must log in to Pearson+
for the etext.](16_files/self_check_11_020b.png)

## Key Terms

  * [actual type](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005FA2.xhtml#P7001018329000000000000000005FBF)

  * [casting objects](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000601A.xhtml#P700101832900000000000000000602B)

  * [constructor chaining](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005E00.xhtml#P7001018329000000000000000005E46)

  * [declared type](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005FA2.xhtml#P7001018329000000000000000005FBB)

  * [dynamic binding](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005FA2.xhtml#P7001018329000000000000000005FC5)

  * [inheritance](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005CFF.xhtml#P7001018329000000000000000005D0B)

  * [`instanceof`](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP700101832900000000000000000601A.xhtml#P7001018329000000000000000006049)

  * [is-a relationship](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000006282.xhtml#P70010183290000000000000000062B7)

  * [method overriding](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005EAA.xhtml#P7001018329000000000000000005EB4)

  * [multiple inheritance](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005DF3)

  * [override](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005EAA.xhtml#P7001018329000000000000000005EB8)

  * [polymorphism](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005F81.xhtml#P7001018329000000000000000005F98)

  * [protected](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP70010183290000000000000000062C1.xhtml#P70010183290000000000000000062CF)

  * [single inheritance](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005DF5)

  * [subclass](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005D5E)

  * [subtype](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005D67)

  * [superclass](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005D60)

  * [supertype](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000005D0C.xhtml#P7001018329000000000000000005D68)

  * [type inference](https://jigsaw.vitalsource.com/books/9780138123352/epub/OPS/xhtml/fileP7001018329000000000000000006114.xhtml#P7001018329000000000000000006150)

